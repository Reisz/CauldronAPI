CStringList = class("CStringList", CList)

function CStringList:initialize(...)
    local list = {...}
    for i, v in ipairs(list) do
        list[i] = tostring(v)
    end
    CList.initialize(self, unpack(list))
end

function CStringList.static.fromList(list)
    assert(instanceOf(CList, list), "List not instance of CList")
    return CStringList(list:unpack())
end

function CStringList.static.splitString(input, split, plain, ignoreEmpty)
    local result, i = {}, 1

    while true do
        local newI = string.find(input, split, i, plain)
        if not newI then
            local sub = string.sub(input, i)
            if not (ignoreEmpty and #sub == 0) then
                table.insert(result, sub)
            end
            return CStringList(unpack(result))
        end
        local sub = string.sub(input, i, newI - 1)
        if not (ignoreEmpty and #sub == 0) then
            table.insert(result, sub)
        end
        i = newI + 1
    end
end

function CStringList:concat(sep, i, j)
    sep = sep or ""
    i = i or 1
    j = j or self:length()
    return table.concat(self:toTable(), sep, i, j)
end

function CStringList:insert(pos, value)
    if value == nil then
        value = pos
        pos = self:length() + 1
    end
    CList.insert(self, pos, tostring(value))
end

function CStringList:find(value, plain)
    if plain then return CList.find(self, value) end
    for i,v in ipairs(self:toTable()) do
        if string.find(v, value) then return i end
    end
    return nil
end

function CStringList:findAll(value, plain)
    if plain then return CList.findAll(self, value) end
    local result = {}
    for i, v in ipairs(self:toTable()) do
        if string.find(v, value) then table.insert(result, i) end
    end
    return unpack(result)
end